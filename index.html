<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberPurge FPS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            color: #00ffff;
            background-color: #000;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
        }
        #healthBar, #energyBar, #armorBar {
            width: 200px;
            height: 20px;
            background-color: #333;
            margin-bottom: 10px;
            border: 2px solid #00ffff;
        }
        #healthFill, #energyFill, #armorFill {
            height: 100%;
            transition: width 0.3s;
        }
        #ammoCounter, #dataShards {
            font-size: 18px;
            margin-bottom: 5px;
        }
        #startScreen, #gameOverScreen, #pauseScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
        }
        #gameOverScreen, #pauseScreen {
            display: none;
        }
        h1 {
            font-size: 4em;
            margin-bottom: 20px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        button {
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: #00ffff;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #00cccc;
            transform: scale(1.05);
        }
        #weaponSelector {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
        }
        .weapon {
            padding: 10px;
            margin: 5px;
            background-color: #333;
            border: 2px solid #00ffff;
            cursor: pointer;
            opacity: 0.5;
        }
        .weapon.active {
            opacity: 1;
        }
        .weapon.locked {
            border-color: #ff3333;
            cursor: not-allowed;
        }
        #waveInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 24px;
            z-index: 10;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 5;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: #00ffff;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #notifications {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
        }
        .notification {
            padding: 10px;
            background-color: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            margin-bottom: 5px;
            border-radius: 5px;
            animation: fadeOut 2s forwards;
            animation-delay: 2s;
        }
        @keyframes fadeOut {
            to {
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="startScreen">
            <h1>CYBER PURGE</h1>
            <p>Year 2087 - Eliminate rogue AI bots that have overrun the city</p>
            <div>
                <p>Controls: WASD to move, SHIFT to sprint, SPACE to jump</p>
                <p>Left click to shoot, R to reload, E to place landmine (if available)</p>
                <p>Press ESC to pause the game</p>
            </div>
            <button id="startButton">START MISSION</button>
        </div>
        
        <div id="gameOverScreen">
            <h1>MISSION FAILED</h1>
            <p id="finalScore">Time: 00:00</p>
            <button id="restartButton">RETRY MISSION</button>
        </div>
        
        <div id="pauseScreen">
            <h1>PAUSED</h1>
            <button id="resumeButton">RESUME</button>
            <button id="quitButton">QUIT</button>
        </div>
        
        <div id="hud">
            <div id="armorBar"><div id="armorFill" style="width: 0%"></div></div>
            <div id="healthBar"><div id="healthFill" style="width: 100%"></div></div>
            <div id="energyBar"><div id="energyFill" style="width: 100%"></div></div>
            <div id="ammoCounter">Ammo: 30/120</div>
            <div id="dataShards">Data Shards: 0</div>
        </div>
        
        <div id="waveInfo">Wave: 0/30</div>
        
        <div id="weaponSelector">
            <div class="weapon active" data-weapon="pulseRifle">Pulse Rifle</div>
            <div class="weapon locked" data-weapon="cyberShotgun">Cyber Shotgun (10 shards)</div>
            <div class="weapon locked" data-weapon="plasmaLauncher">Plasma Launcher (25 shards)</div>
            <div class="weapon" data-weapon="electricKatana">Electric Katana</div>
        </div>
        
        <div id="crosshair"></div>
        <div id="notifications"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // Game state
        let isGameStarted = false;
        let isGameOver = false;
        let isPaused = false;
        let elapsedTime = 0;
        let prevTime = 0;
        let deltaTime = 0;
        let currentWave = 0;
        
        // Player state
        const player = {
            health: 100,
            maxHealth: 100,
            energy: 100,
            maxEnergy: 100,
            speed: 100,
            dataShards: 0,
            armor: 0,
            maxArmor: 50,
            weapons: {
                pulseRifle: {
                    damage: 3,
                    magSize: 30,
                    currentMag: 30,
                    totalAmmo: 120,
                    reloadTime: 3,
                    isReloading: false,
                    reloadStart: 0,
                    lastFired: 0,
                    fireDelay: 0.1
                },
                cyberShotgun: {
                    damage: 2,
                    pellets: 15,
                    magSize: 8,
                    currentMag: 8,
                    totalAmmo: 24,
                    reloadTime: 4,
                    isReloading: false,
                    reloadStart: 0,
                    lastFired: 0,
                    fireDelay: 1.5,
                    unlocked: false
                },
                plasmaLauncher: {
                    damage: 50,
                    explosionRadius: 30,
                    magSize: 2,
                    currentMag: 2,
                    totalAmmo: 18,
                    reloadTime: 5.5,
                    isReloading: false,
                    reloadStart: 0,
                    lastFired: 0,
                    fireDelay: 2.5,
                    unlocked: false
                },
                electricKatana: {
                    damage: 6,
                    lastFired: 0,
                    fireDelay: 1
                }
            },
            currentWeapon: 'pulseRifle',
            hasPowerups: {
                speed: { active: false, duration: 0, startTime: 0 },
                reloadBoost: false,
                oneTap: false,
                noDelay: { active: false, duration: 0, startTime: 0 },
                landmine: false
            }
        };
        
        // Movement state
        const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            run: false,
            jump: false
        };
        
        // Game elements
        let camera, scene, renderer;
        let controls;
        let enemies = [];
        let bullets = [];
        let pickups = [];
        let obstacles = [];
        
        // Weapon models
        let weaponModel = null;
        let swingAnimation = null;
        let isSwinging = false;
        
        // Initialize Three.js scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.FogExp2(0x000000, 0.002);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.y = 10;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Pointer lock controls
            controls = new THREE.PointerLockControls(camera, document.body);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create floor
            const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Create boundary walls
            createBoundaryWalls();
            
            // Create random obstacles
            createRandomObstacles();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('restartButton').addEventListener('click', restartGame);
            document.getElementById('resumeButton').addEventListener('click', resumeGame);
            document.getElementById('quitButton').addEventListener('click', quitGame);
            
            // Weapon selection
            document.querySelectorAll('.weapon').forEach(element => {
                element.addEventListener('click', () => {
                    const weaponType = element.getAttribute('data-weapon');
                    if (element.classList.contains('locked')) {
                        showNotification(`Weapon locked. Need more data shards.`);
                        return;
                    }
                    
                    player.currentWeapon = weaponType;
                    document.querySelectorAll('.weapon').forEach(w => w.classList.remove('active'));
                    element.classList.add('active');
                    updateUI();
                });
            });
            
            // Create weapon models
            createWeaponModels();
            
            // Initialize UI
            updateUI();
            
            // Start animation loop
            animate();
        }
        
        function createBoundaryWalls() {
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0088ff,
                metalness: 0.7,
                roughness: 0.2,
                emissive: 0x001133
            });
            
            // North wall
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(1000, 50, 10),
                wallMaterial
            );
            northWall.position.set(0, 25, -505);
            scene.add(northWall);
            obstacles.push({ mesh: northWall, type: 'wall' });
            
            // South wall
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(1000, 50, 10),
                wallMaterial
            );
            southWall.position.set(0, 25, 505);
            scene.add(southWall);
            obstacles.push({ mesh: southWall, type: 'wall' });
            
            // East wall
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(10, 50, 1000),
                wallMaterial
            );
            eastWall.position.set(505, 25, 0);
            scene.add(eastWall);
            obstacles.push({ mesh: eastWall, type: 'wall' });
            
            // West wall
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(10, 50, 1000),
                wallMaterial
            );
            westWall.position.set(-505, 25, 0);
            scene.add(westWall);
            obstacles.push({ mesh: westWall, type: 'wall' });
        }
        
        function createRandomObstacles() {
            const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.5,
                metalness: 0.3
            });
            
            // Create random walls and obstacles
            for (let i = 0; i < 50; i++) {
                const obstacleSize = {
                    width: Math.random() * 30 + 10,
                    height: Math.random() * 20 + 10,
                    depth: Math.random() * 30 + 10
                };
                
                const x = (Math.random() - 0.5) * 900;
                const z = (Math.random() - 0.5) * 900;
                
                // Don't place obstacles too close to spawn point
                if (Math.abs(x) < 50 && Math.abs(z) < 50) continue;
                
                const obstacle = new THREE.Mesh(
                    new THREE.BoxGeometry(obstacleSize.width, obstacleSize.height, obstacleSize.depth),
                    obstacleMaterial
                );
                
                obstacle.position.set(x, obstacleSize.height / 2, z);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                
                scene.add(obstacle);
                obstacles.push({ mesh: obstacle, type: 'obstacle' });
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onKeyDown(event) {
            if (isGameOver || !isGameStarted || isPaused) return;
            
            switch (event.code) {
                case 'KeyW':
                    moveState.forward = true;
                    break;
                case 'KeyS':
                    moveState.backward = true;
                    break;
                case 'KeyA':
                    moveState.left = true;
                    break;
                case 'KeyD':
                    moveState.right = true;
                    break;
                case 'ShiftLeft':
                    moveState.run = true;
                    break;
                case 'Space':
                    moveState.jump = true;
                    break;
                case 'KeyR':
                    reload();
                    break;
                case 'KeyE':
                    placeLandmine();
                    break;
                case 'KeyQ':
                    shoot();
                    break;
                case 'Escape':
                    togglePause();
                    break;
                case 'Digit1':
                    if (!player.weapons.pulseRifle.unlocked) return;
                    player.currentWeapon = 'pulseRifle';
                    updateWeaponUI();
                    showWeapon();
                    break;
                case 'Digit2':
                    if (!player.weapons.cyberShotgun.unlocked) return;
                    player.currentWeapon = 'cyberShotgun';
                    updateWeaponUI();
                    showWeapon();
                    break;
                case 'Digit3':
                    if (!player.weapons.plasmaLauncher.unlocked) return;
                    player.currentWeapon = 'plasmaLauncher';
                    updateWeaponUI();
                    showWeapon();
                    break;
                case 'Digit4':
                    player.currentWeapon = 'electricKatana';
                    updateWeaponUI();
                    showWeapon();
                    break;
            }
        }
        
        function onKeyUp(event) {
            if (isGameOver) return;
            
            switch (event.code) {
                case 'KeyW':
                    moveState.forward = false;
                    break;
                case 'KeyS':
                    moveState.backward = false;
                    break;
                case 'KeyA':
                    moveState.left = false;
                    break;
                case 'KeyD':
                    moveState.right = false;
                    break;
                case 'ShiftLeft':
                    moveState.run = false;
                    break;
            }
        }
        
        function onMouseDown(event) {
            if (isGameOver || !isGameStarted || isPaused) return;
            
            if (event.button === 0) { // Left click
                shoot();
            }
        }
        
        function onMouseUp(event) {
            // Currently not needed
        }
        
        function startGame() {
            isGameStarted = true;
            controls.lock();
            
            // Hide start screen
            document.getElementById('startScreen').style.display = 'none';
            
            // Add pointer lock event listeners
            controls.addEventListener('lock', function() {
                if (isPaused) {
                    resumeGame();
                }
            });
            
            controls.addEventListener('unlock', function() {
                if (isGameStarted && !isGameOver) {
                    pauseGame();
                }
            });
            
            // Initialize player and game
            player.weapons.pulseRifle.unlocked = true;
            
            // Start first wave
            startWave(1);
            
            // Reset time
            prevTime = performance.now();
            elapsedTime = 0;
        }
        
        function restartGame() {
            // Reset game state
            isGameStarted = true;
            isGameOver = false;
            elapsedTime = 0;
            currentWave = 0;
            
            // Reset player
            player.health = player.maxHealth;
            player.energy = player.maxEnergy;
            player.dataShards = 0;
            player.currentWeapon = 'pulseRifle';
            
            player.weapons = {
                pulseRifle: {
                    damage: 3,
                    magSize: 30,
                    currentMag: 30,
                    totalAmmo: 120,
                    reloadTime: 3,
                    isReloading: false,
                    reloadStart: 0,
                    lastFired: 0,
                    fireDelay: 0.1,
                    unlocked: true
                },
                cyberShotgun: {
                    damage: 2,
                    pellets: 15,
                    magSize: 8,
                    currentMag: 8,
                    totalAmmo: 24,
                    reloadTime: 4,
                    isReloading: false,
                    reloadStart: 0,
                    lastFired: 0,
                    fireDelay: 1.5,
                    unlocked: false
                },
                plasmaLauncher: {
                    damage: 50,
                    explosionRadius: 30,
                    magSize: 2,
                    currentMag: 2,
                    totalAmmo: 18,
                    reloadTime: 5.5,
                    isReloading: false,
                    reloadStart: 0,
                    lastFired: 0,
                    fireDelay: 2.5,
                    unlocked: false
                },
                electricKatana: {
                    damage: 6,
                    lastFired: 0,
                    fireDelay: 1
                }
            };
            
            player.hasPowerups = {
                speed: { active: false, duration: 0, startTime: 0 },
                reloadBoost: false,
                oneTap: false,
                noDelay: { active: false, duration: 0, startTime: 0 },
                landmine: false
            };
            
            // Reset weapons UI
            document.querySelectorAll('.weapon').forEach(element => {
                const weaponType = element.getAttribute('data-weapon');
                if (weaponType === 'pulseRifle' || weaponType === 'electricKatana') {
                    element.classList.remove('locked');
                } else {
                    element.classList.add('locked');
                }
                
                if (weaponType === 'pulseRifle') {
                    element.classList.add('active');
                } else {
                    element.classList.remove('active');
                }
            });
            
            // Clear entities
            clearEntities();
            
            // Hide game over screen
            document.getElementById('gameOverScreen').style.display = 'none';
            
            // Lock controls
            controls.lock();
            
            // Start first wave
            startWave(1);
            
            // Reset time
            prevTime = performance.now();
            updateUI();
        }
        
        function clearEntities() {
            // Remove all enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                scene.remove(enemies[i].mesh);
            }
            enemies = [];
            
            // Remove all bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                scene.remove(bullets[i].mesh);
            }
            bullets = [];
            
            // Remove all pickups
            for (let i = pickups.length - 1; i >= 0; i--) {
                scene.remove(pickups[i].mesh);
            }
            pickups = [];
        }
        
        function pauseGame() {
            if (!isGameStarted || isGameOver) return;
            
            isPaused = true;
            document.getElementById('pauseScreen').style.display = 'flex';
        }
        
        function resumeGame() {
            isPaused = false;
            document.getElementById('pauseScreen').style.display = 'none';
            prevTime = performance.now(); // Reset time to avoid huge delta
        }
        
        function quitGame() {
            isGameStarted = false;
            isPaused = false;
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            controls.unlock();
            clearEntities();
        }
        
        function togglePause() {
            if (isPaused) {
                resumeGame();
                controls.lock();
            } else {
                pauseGame();
                controls.unlock();
            }
        }
        
        function gameOver() {
            isGameOver = true;
            isPaused = false;
            
            const finalTime = formatTime(elapsedTime);
            document.getElementById('finalScore').textContent = `Time: ${finalTime}`;
            document.getElementById('gameOverScreen').style.display = 'flex';
            
            controls.unlock();
        }
        
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        function startWave(waveNumber) {
            currentWave = waveNumber;
            
            // Show wave notification
            showNotification(`Wave ${currentWave} starting!`);
            
            // Calculate number of enemies based on wave
            const numDrones = Math.floor(waveNumber * 1.5);
            const numGuardians = Math.floor(waveNumber * 0.5);
            const numOverseers = waveNumber >= 25 ? Math.floor((waveNumber - 24) * 0.5) : 0;
            
            // Spawn enemies
            for (let i = 0; i < numDrones; i++) {
                spawnEnemy('drone');
            }
            
            for (let i = 0; i < numGuardians; i++) {
                spawnEnemy('guardian');
            }
            
            for (let i = 0; i < numOverseers; i++) {
                spawnEnemy('overseer');
            }
            
            // Spawn crates
            const crateChance = 0.2 + (waveNumber * 0.015); // Increased from 0.1 + 0.01
            if (Math.random() < crateChance) {
                spawnCrate('ammo');
            }
            
            if (Math.random() < crateChance) {
                spawnCrate('powerup');
            }
            
            updateUI();
        }
        
        function spawnEnemy(type) {
            let enemy = {
                type: type,
                position: new THREE.Vector3(),
                velocity: new THREE.Vector3(),
                health: 10,
                lastAttack: 0,
                attackDelay: 1
            };
            
            // Set enemy properties based on type with slower speeds
            switch (type) {
                case 'drone':
                    enemy.health = 10;
                    enemy.damage = 10;
                    enemy.speed = 35; // Reduced from 50
                    enemy.dropChance = 0.25;
                    enemy.mesh = new THREE.Mesh(
                        new THREE.SphereGeometry(5, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0xff0000 })
                    );
                    break;
                    
                case 'guardian':
                    enemy.health = 20;
                    enemy.damage = 15;
                    enemy.speed = 35; // Reduced from 50
                    enemy.canShoot = true;
                    enemy.shootChance = 0.01; // Per frame
                    enemy.bulletDamage = 5;
                    enemy.dropChance = 0.5;
                    enemy.mesh = new THREE.Mesh(
                        new THREE.SphereGeometry(6, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0xff7700 })
                    );
                    break;
                    
                case 'overseer':
                    enemy.health = 100;
                    enemy.damage = 20;
                    enemy.speed = 25; // Reduced from 37.5
                    enemy.canShoot = true;
                    enemy.shootChance = 0.005; // Per frame
                    enemy.bulletDamage = 5;
                    enemy.bulletBurst = 5;
                    enemy.dropChance = 1; // 100%
                    enemy.mesh = new THREE.Mesh(
                        new THREE.SphereGeometry(10, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0xff0077 })
                    );
                    break;
            }
            
            // Position enemy randomly, but not too close to player and not inside obstacles
            let validPosition = false;
            let attempts = 0;
            
            while (!validPosition && attempts < 100) { // Increased max attempts
                const x = (Math.random() - 0.5) * 900;
                const z = (Math.random() - 0.5) * 900;
                
                // Check distance from player
                const distToPlayer = Math.sqrt(
                    Math.pow(x - camera.position.x, 2) + 
                    Math.pow(z - camera.position.z, 2)
                );
                
                if (distToPlayer > 100) { // Must be at least 100 units away
                    // Check if position intersects with any obstacle
                    let obstacleCollision = false;
                    
                    // Create a temporary enemy to check collisions
                    const tempEnemy = {
                        position: new THREE.Vector3(x, enemy.mesh.geometry.parameters.radius, z),
                        mesh: { geometry: { parameters: { radius: enemy.mesh.geometry.parameters.radius } } }
                    };
                    
                    if (!checkEnemyObstacleCollision(tempEnemy)) {
                        enemy.position.copy(tempEnemy.position);
                        validPosition = true;
                    }
                }
                
                attempts++;
            }
            
            // If couldn't find valid position after max attempts, just place somewhere random
            if (!validPosition) {
                const x = (Math.random() - 0.5) * 900;
                const z = (Math.random() - 0.5) * 900;
                enemy.position.set(x, enemy.mesh.geometry.parameters.radius, z);
            }
            
            enemy.mesh.position.copy(enemy.position);
            enemy.mesh.castShadow = true;
            scene.add(enemy.mesh);
            
            enemies.push(enemy);
        }
        
        function spawnCrate(type) {
            let crate = {
                type: type,
                position: new THREE.Vector3(),
                collected: false
            };
            
            // Set crate properties based on type
            if (type === 'ammo') {
                crate.mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.5
                    })
                );
            } else if (type === 'powerup') {
                crate.mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff00ff,
                        emissive: 0xff00ff,
                        emissiveIntensity: 0.5
                    })
                );
            }
            
            // Position crate randomly, but not too close to player and not inside obstacles
            let validPosition = false;
            let attempts = 0;
            
            while (!validPosition && attempts < 100) { // Increased max attempts
                const x = (Math.random() - 0.5) * 900;
                const z = (Math.random() - 0.5) * 900;
                
                // Check distance from player
                const distToPlayer = Math.sqrt(
                    Math.pow(x - camera.position.x, 2) + 
                    Math.pow(z - camera.position.z, 2)
                );
                
                if (distToPlayer > 50) { // Must be at least 50 units away
                    // Create a temporary object for collision checking
                    const tempBox = {
                        position: new THREE.Vector3(x, 4, z),
                        mesh: { geometry: { parameters: { radius: 5 } } } // Treat box as sphere for collision
                    };
                    
                    if (!checkEnemyObstacleCollision(tempBox)) { // Reuse the same collision check
                        crate.position.set(x, 4, z);
                        validPosition = true;
                    }
                }
                
                attempts++;
            }
            
            // If couldn't find valid position after max attempts, just place somewhere random
            if (!validPosition) {
                const x = (Math.random() - 0.5) * 900;
                const z = (Math.random() - 0.5) * 900;
                crate.position.set(x, 4, z);
            }
            
            crate.mesh.position.copy(crate.position);
            crate.mesh.castShadow = true;
            scene.add(crate.mesh);
            
            pickups.push(crate);
        }
        
        function updatePlayerPosition() {
            if (!isGameStarted || isGameOver || isPaused) return;
            
            // Handle movement
            let moveX = 0;
            let moveZ = 0;
            
            // SWAP THE DIRECTION: forward is now positive Z, backward is negative Z
            if (moveState.forward) moveZ += 1; // W key - now moves positive Z
            if (moveState.backward) moveZ -= 1; // S key - now moves negative Z
            if (moveState.left) moveX -= 1;
            if (moveState.right) moveX += 1;
            
            // Normalize for diagonal movement
            if (moveX !== 0 && moveZ !== 0) {
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                moveX /= length;
                moveZ /= length;
            }
            
            // Apply speed
            let speed = player.speed;
            if (moveState.run && player.energy > 0) {
                speed *= 1.8;
                player.energy = Math.max(0, player.energy - 10 * deltaTime);
                updateUI();
            }
            
            // Apply speed powerup
            if (player.hasPowerups.speed.active) {
                speed *= 2;
                
                // Check if powerup has expired
                if (elapsedTime - player.hasPowerups.speed.startTime > player.hasPowerups.speed.duration) {
                    player.hasPowerups.speed.active = false;
                    showNotification("Speed boost expired!");
                }
            }
            
            moveX *= speed * deltaTime;
            moveZ *= speed * deltaTime;
            
            // Store current position before moving
            const oldPosition = new THREE.Vector3().copy(camera.position);
            
            // Move camera - use moveZ directly (no negative)
            if (moveX !== 0 || moveZ !== 0) {
                controls.moveRight(moveX);
                controls.moveForward(moveZ); // Use moveZ directly
                
                // Keep player within boundaries
                if (camera.position.x < -495) camera.position.x = -495;
                if (camera.position.x > 495) camera.position.x = 495;
                if (camera.position.z < -495) camera.position.z = -495;
                if (camera.position.z > 495) camera.position.z = 495;
                
                // Check for collisions with obstacles
                if (checkObstacleCollisions()) {
                    // If collision detected, revert to old position
                    camera.position.copy(oldPosition);
                }
            }
            
            // Handle jumping (simplified)
            if (moveState.jump) {
                moveState.jump = false;
            }
            
            // Regenerate energy when not running
            if (!moveState.run && player.energy < player.maxEnergy) {
                player.energy = Math.min(player.maxEnergy, player.energy + 5 * deltaTime);
                updateUI();
            }
            
            // Regenerate health (1 per second)
            if (player.health < player.maxHealth) {
                player.health = Math.min(player.maxHealth, player.health + deltaTime);
                updateUI();
            }
            
            // Check if player is overlapping with pickups
            checkPickupCollisions();
        }
        
        function checkObstacleCollisions() {
            // Player collision radius (effectively player's "width")
            const playerRadius = 5;
            
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                
                // Skip boundary walls as they already have their own collision logic
                if (obstacle.type === 'wall') continue;
                
                const obstaclePos = obstacle.mesh.position;
                
                // Get obstacle dimensions
                const obstacleSize = new THREE.Vector3(
                    obstacle.mesh.geometry.parameters.width || 0,
                    obstacle.mesh.geometry.parameters.height || 0,
                    obstacle.mesh.geometry.parameters.depth || 0
                );
                
                // Calculate half-extents of the obstacle
                const halfWidth = obstacleSize.x / 2;
                const halfDepth = obstacleSize.z / 2;
                
                // Calculate the closest point on the obstacle to the player
                const closestX = Math.max(obstaclePos.x - halfWidth, Math.min(camera.position.x, obstaclePos.x + halfWidth));
                const closestZ = Math.max(obstaclePos.z - halfDepth, Math.min(camera.position.z, obstaclePos.z + halfDepth));
                
                // Calculate distance from closest point to player
                const distanceX = camera.position.x - closestX;
                const distanceZ = camera.position.z - closestZ;
                const distanceSquared = distanceX * distanceX + distanceZ * distanceZ;
                
                // Check if distance is less than player radius
                if (distanceSquared < playerRadius * playerRadius) {
                    return true; // Collision detected
                }
            }
            
            return false; // No collision
        }
        
        function checkPickupCollisions() {
            for (let i = pickups.length - 1; i >= 0; i--) {
                const pickup = pickups[i];
                if (pickup.collected) continue;
                
                // Calculate distance to player
                const dist = Math.sqrt(
                    Math.pow(pickup.position.x - camera.position.x, 2) + 
                    Math.pow(pickup.position.z - camera.position.z, 2)
                );
                
                if (dist < 10) { // Pickup radius
                    // Collect pickup
                    collectPickup(pickup);
                    scene.remove(pickup.mesh);
                    pickup.collected = true;
                    pickups.splice(i, 1);
                }
            }
        }
        
        function collectPickup(pickup) {
            if (pickup.type === 'ammo') {
                // Random ammo type
                const rand = Math.random();
                
                if (rand < 0.33 || player.currentWeapon === 'pulseRifle') {
                    player.weapons.pulseRifle.totalAmmo += 60;
                    showNotification("+60 Pulse Rifle Ammo");
                } else if (rand < 0.66 || player.currentWeapon === 'cyberShotgun') {
                    player.weapons.cyberShotgun.totalAmmo += 16;
                    showNotification("+16 Cyber Shotgun Ammo");
                } else {
                    player.weapons.plasmaLauncher.totalAmmo += 3;
                    showNotification("+3 Plasma Launcher Ammo");
                }
            } else if (pickup.type === 'powerup') {
                // Random powerup with more options
                const rand = Math.random();
                
                if (rand < 0.15) {
                    // Speed boost
                    player.hasPowerups.speed.active = true;
                    player.hasPowerups.speed.startTime = elapsedTime;
                    player.hasPowerups.speed.duration = 10;
                    showNotification("Speed Boost: 2x speed for 10 seconds!");
                } else if (rand < 0.3) {
                    // Reload boost
                    player.hasPowerups.reloadBoost = true;
                    showNotification("Reload Boost: 30% faster reloads permanently!");
                } else if (rand < 0.45) {
                    // One tap
                    player.hasPowerups.oneTap = true;
                    showNotification("One Tap: Next shot instantly kills target!");
                } else if (rand < 0.6) {
                    // No delay
                    player.hasPowerups.noDelay.active = true;
                    player.hasPowerups.noDelay.startTime = elapsedTime;
                    player.hasPowerups.noDelay.duration = 10;
                    showNotification("No Delay: Rapid fire for 10 seconds!");
                } else if (rand < 0.75) {
                    // Health Boost (NEW)
                    player.health = player.maxHealth;
                    showNotification("Health fully restored!");
                } else if (rand < 0.9) {
                    // Armor (NEW)
                    player.armor = player.maxArmor;
                    showNotification("Armor acquired! Extra protection from damage.");
                } else {
                    // Landmine
                    player.hasPowerups.landmine = true;
                    showNotification("Landmine acquired! Press E to deploy.");
                }
            }
            
            updateUI();
        }
        
        function placeLandmine() {
            if (!player.hasPowerups.landmine) return;
            
            // Create landmine
            const landmine = {
                position: new THREE.Vector3(camera.position.x, 0.5, camera.position.z),
                damage: 100,
                radius: 20,
                playerOwned: true // Mark as player owned
            };
            
            // Create more visible landmine mesh
            landmine.mesh = new THREE.Mesh(
                new THREE.CylinderGeometry(5, 5, 1, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.7 // More intense glow
                })
            );
            
            // Add a blinking light to make it more visible
            const landmineLight = new THREE.PointLight(0x00ff00, 1, 10);
            landmineLight.position.set(0, 1, 0);
            landmine.mesh.add(landmineLight);
            
            // Create animation for blinking
            landmine.blinkInterval = setInterval(() => {
                landmineLight.visible = !landmineLight.visible;
            }, 500); // Blink every half second
            
            landmine.mesh.position.copy(landmine.position);
            scene.add(landmine.mesh);
            
            // Add to pickups array but mark as special type
            landmine.type = 'landmine';
            pickups.push(landmine);
            
            // Remove powerup from player
            player.hasPowerups.landmine = false;
            showNotification("Landmine deployed!");
        }
        
        function shoot() {
            if (isGameOver || !isGameStarted || isPaused) return;
            
            const weapon = player.weapons[player.currentWeapon];
            
            // Check if weapon is reloading
            if (weapon.isReloading) return;
            
            // Check if weapon has enough ammo
            if (player.currentWeapon !== 'electricKatana' && weapon.currentMag <= 0) {
                reload();
                return;
            }
            
            // Check fire delay
            if (elapsedTime - weapon.lastFired < weapon.fireDelay && !player.hasPowerups.noDelay.active) {
                return;
            }
            
            // Update last fired time
            weapon.lastFired = elapsedTime;
            
            // Consume ammo for non-melee weapons
            if (player.currentWeapon !== 'electricKatana') {
                weapon.currentMag--;
            }
            
            // Create bullet(s) based on weapon type
            if (player.currentWeapon === 'pulseRifle') {
                createBullet(weapon.damage);
            } else if (player.currentWeapon === 'cyberShotgun') {
                for (let i = 0; i < weapon.pellets; i++) {
                    createBullet(weapon.damage, 0.1); // Spread
                }
            } else if (player.currentWeapon === 'plasmaLauncher') {
                createBullet(weapon.damage, 0, true); // Explosive
            } else if (player.currentWeapon === 'electricKatana') {
                meleeAttack(weapon.damage);
            }
            
            updateUI();
        }
        
        function createBullet(damage, spread = 0, explosive = false) {
            // Calculate direction with spread
            const direction = new THREE.Vector3(0, 0, -1);
            
            if (spread > 0) {
                direction.x += (Math.random() - 0.5) * spread * 2;
                direction.y += (Math.random() - 0.5) * spread * 2;
                direction.z += (Math.random() - 0.5) * spread * 2;
                direction.normalize();
            }
            
            direction.applyQuaternion(camera.quaternion);
            
            // Create bullet object
            const bullet = {
                position: new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z),
                direction: direction,
                speed: 500,
                damage: damage,
                explosive: explosive,
                explosionRadius: explosive ? player.weapons.plasmaLauncher.explosionRadius : 0,
                isPlayerBullet: true
            };
            
            // Apply one tap powerup if active
            if (player.hasPowerups.oneTap) {
                bullet.oneTap = true;
                player.hasPowerups.oneTap = false;
                showNotification("One Tap activated!");
            }
            
            // Create bullet mesh
            if (explosive) {
                bullet.mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(2, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.8
                    })
                );
            } else {
                bullet.mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                );
            }
            
            bullet.mesh.position.copy(bullet.position);
            scene.add(bullet.mesh);
            
            bullets.push(bullet);
        }
        
        function meleeAttack(damage) {
            if (isSwinging) return; // Don't attack if already swinging
            
            isSwinging = true;
            const katana = player.weaponModels.electricKatana;
            const duration = player.weapons.electricKatana.fireDelay * 1000; // Convert to milliseconds
            
            // Store original rotation
            const originalRotation = {
                x: katana.rotation.x,
                y: katana.rotation.y,
                z: katana.rotation.z
            };
            
            // Create a dramatic swing effect
            const swingTrail = new THREE.Mesh(
                new THREE.PlaneGeometry(3, 0.5),
                new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                })
            );
            
            // Position the trail along the blade
            swingTrail.position.z = -1.5;
            katana.add(swingTrail);
            
            // Animation timeline
            const startTime = performance.now();
            
            function swingAnimation() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                if (progress < 0.5) {
                    // First half - swing down with arcing motion
                    const swingProgress = progress * 2; // Scale to 0-1 for first half
                    katana.rotation.x = originalRotation.x + Math.PI * swingProgress; // Full 180 degree swing
                    
                    // Update trail opacity and size for effect
                    swingTrail.material.opacity = 0.7;
                    swingTrail.scale.y = 1 + swingProgress * 2;
                } else if (progress < 1) {
                    // Second half - return to starting position
                    const returnProgress = (progress - 0.5) * 2; // Scale to 0-1 for second half
                    katana.rotation.x = originalRotation.x + Math.PI - (Math.PI * returnProgress);
                    
                    // Fade out trail
                    swingTrail.material.opacity = 0.7 * (1 - returnProgress);
                    swingTrail.scale.y = 3 - returnProgress * 2;
                } else {
                    // Animation complete
                    katana.rotation.x = originalRotation.x;
                    katana.rotation.y = originalRotation.y;
                    katana.rotation.z = originalRotation.z;
                    katana.remove(swingTrail);
                    isSwinging = false;
                    return;
                }
                
                requestAnimationFrame(swingAnimation);
            }
            
            // Start animation
            swingAnimation();
            
            // Check for enemies in the swing arc with increased range
            const MELEE_RANGE = 25;
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            // Create a visual swing effect in the world based on katana's orientation
            // First, we need to create a world matrix for the katana
            const katanaMatrix = new THREE.Matrix4();
            katana.updateMatrixWorld();
            katanaMatrix.copy(katana.matrixWorld);
            
            // Get katana's world position and orientation
            const katanaWorldPosition = new THREE.Vector3();
            katana.getWorldPosition(katanaWorldPosition);
            
            // Get the blade tip position in world space
            const bladeTip = new THREE.Vector3(0, 0, -3.5);
            bladeTip.applyMatrix4(katanaMatrix);
            
            // Get katana's forward direction in world space
            const katanaForward = new THREE.Vector3(0, 0, -1);
            katanaForward.applyQuaternion(katana.getWorldQuaternion(new THREE.Quaternion()));
            
            // Create a custom swing effect that matches the katana's orientation
            const swingEffect = new THREE.Mesh(
                new THREE.TorusGeometry(3, 0.2, 8, 32, Math.PI),
                new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.5
                })
            );
            
            // Position the swing effect at the katana's blade position
            swingEffect.position.copy(katanaWorldPosition);
            swingEffect.position.z -= 2; // Move it to blade area
            
            // Match the swing effect's orientation to the katana's orientation
            const katanaQuaternion = new THREE.Quaternion();
            katana.getWorldQuaternion(katanaQuaternion);
            swingEffect.quaternion.copy(katanaQuaternion);
            
            // Rotate the torus to align with swing direction
            swingEffect.rotation.x += Math.PI/2;
            
            scene.add(swingEffect);
            
            // Animate the swing effect along with the katana
            let swingEffectProgress = 0;
            const animateSwingEffect = () => {
                if (swingEffectProgress >= 1 || !isSwinging) {
                    scene.remove(swingEffect);
                    return;
                }
                
                // Update position to follow katana's blade
                katana.getWorldPosition(katanaWorldPosition);
                swingEffect.position.copy(katanaWorldPosition);
                swingEffect.position.z -= 2;
                
                // Update orientation to match katana
                katana.getWorldQuaternion(katanaQuaternion);
                swingEffect.quaternion.copy(katanaQuaternion);
                swingEffect.rotation.x += Math.PI/2;
                
                // Also rotate the swing effect to follow the katana's swing
                const swingAngle = originalRotation.x + 
                    (swingEffectProgress < 0.5 ? 
                        Math.PI * swingEffectProgress * 2 : 
                        Math.PI * (2 - swingEffectProgress * 2));
                swingEffect.rotation.y = swingAngle;
                
                swingEffectProgress += 0.05;
                swingEffect.material.opacity = 0.5 * (1 - swingEffectProgress);
                swingEffect.scale.multiplyScalar(1.03);
                
                requestAnimationFrame(animateSwingEffect);
            };
            animateSwingEffect();
            
            // Check for enemies in the swing arc with increased range
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                
                // Calculate vector from player to enemy
                const toEnemy = new THREE.Vector3().subVectors(enemy.position, camera.position);
                
                // Calculate distance
                const distance = toEnemy.length();
                
                // Check if enemy is within increased range
                if (distance > MELEE_RANGE) continue;
                
                // Check if enemy is in front of player (dot product with forward vector)
                // Wider angle for easier hits (50 degree cone instead of 45)
                const normalizedToEnemy = toEnemy.clone().normalize();
                const dot = direction.dot(normalizedToEnemy);
                if (dot < 0.65) continue; // Wider angle for hits
                
                // Apply damage to enemy
                damageEnemy(enemy, damage);
                
                // Visual effect for hit
                const hitEffect = new THREE.Mesh(
                    new THREE.SphereGeometry(2, 8, 8),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                
                hitEffect.position.copy(enemy.position);
                scene.add(hitEffect);
                
                // Add electric arc effect between katana and enemy
                const arcGeometry = new THREE.CylinderGeometry(0.1, 0.1, distance, 8);
                arcGeometry.rotateX(Math.PI/2);
                const arcMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.6
                });
                const arc = new THREE.Mesh(arcGeometry, arcMaterial);
                
                // Position the arc between the katana and enemy
                const midPoint = new THREE.Vector3().addVectors(
                    camera.position,
                    enemy.position
                ).multiplyScalar(0.5);
                arc.position.copy(midPoint);
                arc.lookAt(enemy.position);
                scene.add(arc);
                
                // Remove arc and hit effect after short delay
                setTimeout(() => {
                    scene.remove(hitEffect);
                    scene.remove(arc);
                }, 200);
            }
        }
        
        function reload() {
            if (isGameOver || !isGameStarted || isPaused) return;
            
            const weapon = player.weapons[player.currentWeapon];
            
            // Can't reload melee weapons
            if (player.currentWeapon === 'electricKatana') return;
            
            // Already reloading
            if (weapon.isReloading) return;
            
            // No need to reload if mag is full
            if (weapon.currentMag === weapon.magSize) return;
            
            // No ammo left
            if (weapon.totalAmmo <= 0) {
                showNotification("No ammo left!");
                return;
            }
            
            // Start reload
            weapon.isReloading = true;
            weapon.reloadStart = elapsedTime;
            
            // Calculate reload time with potential boost
            let reloadTime = weapon.reloadTime;
            if (player.hasPowerups.reloadBoost) {
                reloadTime *= 0.7; // 30% faster
            }
            
            showNotification(`Reloading... (${reloadTime.toFixed(1)}s)`);
            
            // Set timeout to finish reload
            setTimeout(() => {
                if (!isGameStarted || isGameOver) return;
                
                const ammoNeeded = weapon.magSize - weapon.currentMag;
                const ammoToLoad = Math.min(ammoNeeded, weapon.totalAmmo);
                
                weapon.currentMag += ammoToLoad;
                weapon.totalAmmo -= ammoToLoad;
                weapon.isReloading = false;
                
                showNotification("Reload complete");
                updateUI();
            }, reloadTime * 1000);
        }
        
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Skip if enemy is dead
                if (enemy.health <= 0) continue;
                
                // Calculate vector to player
                const toPlayer = new THREE.Vector3().subVectors(
                    new THREE.Vector3(camera.position.x, enemy.position.y, camera.position.z),
                    enemy.position
                );
                
                // Calculate distance to player
                const distance = toPlayer.length();
                
                // Move towards player if not too close
                if (distance > 5) {
                    // Normalize and apply speed
                    toPlayer.normalize().multiplyScalar(enemy.speed * deltaTime);
                    
                    // Store old position before moving
                    const oldPosition = enemy.position.clone();
                    
                    // Update position
                    enemy.position.add(toPlayer);
                    
                    // Check for obstacle collisions
                    if (checkEnemyObstacleCollision(enemy)) {
                        // Revert to old position if collision detected
                        enemy.position.copy(oldPosition);
                        
                        // Try to navigate around obstacles by moving only on one axis
                        const moveX = new THREE.Vector3(toPlayer.x, 0, 0);
                        enemy.position.add(moveX);
                        if (checkEnemyObstacleCollision(enemy)) {
                            enemy.position.copy(oldPosition);
                            
                            const moveZ = new THREE.Vector3(0, 0, toPlayer.z);
                            enemy.position.add(moveZ);
                            if (checkEnemyObstacleCollision(enemy)) {
                                enemy.position.copy(oldPosition);
                            }
                        }
                    }
                    
                    // Update mesh position
                    enemy.mesh.position.copy(enemy.position);
                }
                
                // Attack player if close enough
                if (distance < 10 && elapsedTime - enemy.lastAttack > enemy.attackDelay) {
                    damagePlayer(enemy.damage);
                    enemy.lastAttack = elapsedTime;
                }
                
                // Ranged enemies can shoot
                if (enemy.canShoot && distance < 100 && Math.random() < enemy.shootChance) {
                    enemyShoot(enemy);
                }
            }
        }
        
        function checkEnemyObstacleCollision(entity) {
            const entityRadius = entity.mesh.geometry.parameters.radius;
            
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                const obstaclePos = obstacle.mesh.position;
                
                // Get obstacle dimensions
                const obstacleSize = new THREE.Vector3(
                    obstacle.mesh.geometry.parameters.width || 0,
                    obstacle.mesh.geometry.parameters.height || 0,
                    obstacle.mesh.geometry.parameters.depth || 0
                );
                
                // Calculate half-extents
                const halfWidth = obstacleSize.x / 2;
                const halfDepth = obstacleSize.z / 2;
                
                // Calculate closest point on obstacle to entity
                const closestX = Math.max(obstaclePos.x - halfWidth, Math.min(entity.position.x, obstaclePos.x + halfWidth));
                const closestZ = Math.max(obstaclePos.z - halfDepth, Math.min(entity.position.z, obstaclePos.z + halfDepth));
                
                // Calculate distance from closest point to player
                const distanceX = entity.position.x - closestX;
                const distanceZ = entity.position.z - closestZ;
                const distanceSquared = distanceX * distanceX + distanceZ * distanceZ;
                
                // Check if distance is less than entity radius
                if (distanceSquared < entityRadius * entityRadius) {
                    return true; // Collision detected
                }
            }
            
            return false; // No collision
        }
        
        function enemyShoot(enemy) {
            // Calculate direction to player with some inaccuracy
            const toPlayer = new THREE.Vector3().subVectors(
                camera.position,
                enemy.position
            ).normalize();
            
            // Add random spread based on enemy type
            const spread = enemy.type === 'guardian' ? 0.1 : 0.05;
            toPlayer.x += (Math.random() - 0.5) * spread * 2;
            toPlayer.y += (Math.random() - 0.5) * spread * 2;
            toPlayer.z += (Math.random() - 0.5) * spread * 2;
            toPlayer.normalize();
            
            // Create bullet
            const bullet = {
                position: new THREE.Vector3().copy(enemy.position),
                direction: toPlayer,
                speed: 200, // Slower than player bullets
                damage: enemy.bulletDamage,
                isPlayerBullet: false
            };
            
            bullet.mesh = new THREE.Mesh(
                new THREE.SphereGeometry(1, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            
            bullet.mesh.position.copy(bullet.position);
            scene.add(bullet.mesh);
            
            bullets.push(bullet);
            
            // For overseer, create a burst of bullets
            if (enemy.type === 'overseer' && enemy.bulletBurst > 1) {
                // Schedule remaining bullets in burst
                for (let i = 1; i < enemy.bulletBurst; i++) {
                    setTimeout(() => {
                        if (!enemy.mesh) return; // Enemy might be dead
                        
                        const burstDir = new THREE.Vector3().copy(toPlayer);
                        burstDir.x += (Math.random() - 0.5) * 0.2;
                        burstDir.y += (Math.random() - 0.5) * 0.2;
                        burstDir.z += (Math.random() - 0.5) * 0.2;
                        burstDir.normalize();
                        
                        const burstBullet = {
                            position: new THREE.Vector3().copy(enemy.position),
                            direction: burstDir,
                            speed: 200,
                            damage: enemy.bulletDamage,
                            isPlayerBullet: false
                        };
                        
                        burstBullet.mesh = new THREE.Mesh(
                            new THREE.SphereGeometry(1, 8, 8),
                            new THREE.MeshBasicMaterial({ color: 0xff0000 })
                        );
                        
                        burstBullet.mesh.position.copy(burstBullet.position);
                        scene.add(burstBullet.mesh);
                        
                        bullets.push(burstBullet);
                    }, i * 100); // 100ms between shots
                }
            }
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Update position
                const movement = bullet.direction.clone().multiplyScalar(bullet.speed * deltaTime);
                bullet.position.add(movement);
                bullet.mesh.position.copy(bullet.position);
                
                // Check for wall collisions
                if (
                    bullet.position.x < -500 || bullet.position.x > 500 ||
                    bullet.position.y < 0 || bullet.position.y > 50 ||
                    bullet.position.z < -500 || bullet.position.z > 500
                ) {
                    // Explode if explosive
                    if (bullet.explosive) {
                        createExplosion(bullet.position, bullet.explosionRadius, bullet.damage);
                    }
                    
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check for obstacle collisions
                for (let j = 0; j < obstacles.length; j++) {
                    const obstacle = obstacles[j];
                    
                    // Simple distance check for collisions
                    const obstaclePos = obstacle.mesh.position;
                    const obstacleSize = new THREE.Vector3(
                        obstacle.mesh.geometry.parameters.width || 0,
                        obstacle.mesh.geometry.parameters.height || 0,
                        obstacle.mesh.geometry.parameters.depth || 0
                    );
                    
                    // Simplified box collision check
                    if (
                        bullet.position.x > obstaclePos.x - obstacleSize.x/2 &&
                        bullet.position.x < obstaclePos.x + obstacleSize.x/2 &&
                        bullet.position.y > obstaclePos.y - obstacleSize.y/2 &&
                        bullet.position.y < obstaclePos.y + obstacleSize.y/2 &&
                        bullet.position.z > obstaclePos.z - obstacleSize.z/2 &&
                        bullet.position.z < obstaclePos.z + obstacleSize.z/2
                    ) {
                        // Explode if explosive
                        if (bullet.explosive) {
                            createExplosion(bullet.position, bullet.explosionRadius, bullet.damage);
                        }
                        
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);
                        break;
                    }
                }
                
                // Continue if bullet was removed due to obstacle collision
                if (i >= bullets.length) continue;
                
                // Check for enemy collisions for player bullets
                if (bullet.isPlayerBullet) {
                    for (let j = 0; j < enemies.length; j++) {
                        const enemy = enemies[j];
                        
                        // Simple distance check for collisions
                        const hitDistance = enemy.mesh.geometry.parameters.radius + 1;
                        const distance = bullet.position.distanceTo(enemy.position);
                        
                        if (distance < hitDistance) {
                            // Apply damage to enemy
                            if (bullet.oneTap) {
                                // One tap kills instantly
                                enemy.health = 0;
                            } else {
                                damageEnemy(enemy, bullet.damage);
                            }
                            
                            // Explode if explosive
                            if (bullet.explosive) {
                                createExplosion(bullet.position, bullet.explosionRadius, bullet.damage);
                            } else {
                                // Remove bullet if not explosive (explosives are removed in explosion)
                                scene.remove(bullet.mesh);
                                bullets.splice(i, 1);
                            }
                            
                            break;
                        }
                    }
                } else {
                    // Check for player collision for enemy bullets
                    const hitDistance = 5; // Player hit box radius
                    const distance = bullet.position.distanceTo(camera.position);
                    
                    if (distance < hitDistance) {
                        damagePlayer(bullet.damage);
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);
                    }
                }
            }
        }
        
        function createExplosion(position, radius, damage) {
            // Visual effect - Make it bigger and more impressive
            const explosion = new THREE.Mesh(
                new THREE.SphereGeometry(radius, 32, 32),
                new THREE.MeshBasicMaterial({ 
                    color: 0xff9900,
                    transparent: true,
                    opacity: 0.7
                })
            );
            
            // Add point light for dramatic effect - make it brighter and larger range
            const explosionLight = new THREE.PointLight(0xff9900, 3, radius * 3);
            explosionLight.position.copy(position);
            scene.add(explosionLight);
            
            // Add secondary smaller, brighter explosion for more visual impact
            const coreExplosion = new THREE.Mesh(
                new THREE.SphereGeometry(radius * 0.3, 16, 16),
                new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.9
                })
            );
            coreExplosion.position.copy(position);
            scene.add(coreExplosion);
            
            explosion.position.copy(position);
            scene.add(explosion);
            
            // Damage enemies in radius
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const distance = position.distanceTo(enemy.position);
                
                if (distance <= radius) {
                    // Calculate damage falloff based on distance
                    const damageMultiplier = 1 - (distance / radius);
                    const explosionDamage = damage * damageMultiplier;
                    damageEnemy(enemy, explosionDamage);
                }
            }
            
            // Check if player is in explosion radius
            const playerDistance = position.distanceTo(camera.position);
            if (playerDistance <= radius) {
                // Player takes reduced damage from own explosions
                const damageMultiplier = 0.5 * (1 - (playerDistance / radius));
                const playerDamage = damage * damageMultiplier;
                damagePlayer(playerDamage);
            }
            
            // Remove explosion after short delay
            setTimeout(() => {
                scene.remove(explosion);
                scene.remove(explosionLight);
                scene.remove(coreExplosion);
            }, 300);
        }
        
        function damagePlayer(damage) {
            // Use armor to absorb damage if available
            if (player.armor > 0) {
                if (player.armor >= damage) {
                    player.armor -= damage;
                    damage = 0;
                } else {
                    damage -= player.armor;
                    player.armor = 0;
                }
            }
            
            // Apply remaining damage to health
            if (damage > 0) {
                player.health -= damage;
            }
            
            if (player.health <= 0) {
                player.health = 0;
                gameOver();
            }
            
            updateUI();
        }
        
        function damageEnemy(enemy, damage) {
            enemy.health -= damage;
            
            if (enemy.health <= 0) {
                // Remove enemy
                scene.remove(enemy.mesh);
                
                // Find enemy index
                const index = enemies.indexOf(enemy);
                if (index !== -1) {
                    enemies.splice(index, 1);
                }
                
                // Random chance to drop data shard
                if (Math.random() < enemy.dropChance) {
                    player.dataShards++;
                    showNotification("+1 Data Shard");
                    
                    // Check if we can unlock weapons
                    if (player.dataShards >= 10 && !player.weapons.cyberShotgun.unlocked) {
                        player.weapons.cyberShotgun.unlocked = true;
                        document.querySelector('[data-weapon="cyberShotgun"]').classList.remove('locked');
                        showNotification("Cyber Shotgun unlocked!");
                    }
                    
                    if (player.dataShards >= 25 && !player.weapons.plasmaLauncher.unlocked) {
                        player.weapons.plasmaLauncher.unlocked = true;
                        document.querySelector('[data-weapon="plasmaLauncher"]').classList.remove('locked');
                        showNotification("Plasma Launcher unlocked!");
                    }
                    
                    updateUI();
                }
            }
        }
        
        function updatePickups() {
            // Check for landmine triggers
            for (let i = pickups.length - 1; i >= 0; i--) {
                const pickup = pickups[i];
                
                if (pickup.type === 'landmine') {
                    // Check if any enemy is close enough to trigger
                    for (let j = 0; j < enemies.length; j++) {
                        const enemy = enemies[j];
                        const distance = pickup.position.distanceTo(enemy.position);
                        
                        if (distance < 7) { // Trigger radius
                            // Create explosion
                            createExplosion(pickup.position, pickup.radius, pickup.damage);
                            
                            // Remove landmine
                            clearInterval(pickup.blinkInterval); // Stop blinking animation
                            scene.remove(pickup.mesh);
                            pickups.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }
        
        function checkWaveProgress() {
            // If all enemies are defeated
            if (enemies.length === 0) {
                if (currentWave < 30) {
                    // Start next wave
                    currentWave++;
                    startWave(currentWave);
                } else if (currentWave === 30) {
                    // Game completed
                    gameOver();
                    document.getElementById('gameOverScreen').querySelector('h1').textContent = 'VICTORY!';
                }
            }
        }
        
        function updateUI() {
            // Update health bar - explicitly set color and ensure width is set as percentage
            const healthFill = document.getElementById('healthFill');
            const healthPercent = (player.health / player.maxHealth) * 100;
            healthFill.style.width = `${healthPercent}%`;
            healthFill.style.backgroundColor = '#ff3333'; // Red for health
            
            // Update energy bar
            const energyFill = document.getElementById('energyFill');
            const energyPercent = (player.energy / player.maxEnergy) * 100;
            energyFill.style.width = `${energyPercent}%`;
            energyFill.style.backgroundColor = '#0000ff'; // Dark blue for energy
            
            // Update armor bar
            const armorFill = document.getElementById('armorFill');
            const armorPercent = ((player.armor || 0) / player.maxArmor) * 100;
            armorFill.style.width = `${armorPercent}%`;
            armorFill.style.backgroundColor = '#00ccff'; // Light blue for armor
            
            // Update ammo counter
            let ammoText = '';
            if (player.currentWeapon === 'electricKatana') {
                ammoText = 'Infinite';
            } else {
                const weapon = player.weapons[player.currentWeapon];
                ammoText = `${weapon.currentMag}/${weapon.totalAmmo}`;
            }
            document.getElementById('ammoCounter').textContent = `Ammo: ${ammoText}`;
            
            // Update data shards counter
            document.getElementById('dataShards').textContent = `Data Shards: ${player.dataShards}`;
            
            // Update wave info
            document.getElementById('waveInfo').textContent = `Wave: ${currentWave}/30`;
        }
        
        function updateWeaponUI() {
            document.querySelectorAll('.weapon').forEach(element => {
                const weaponType = element.getAttribute('data-weapon');
                if (weaponType === player.currentWeapon) {
                    element.classList.add('active');
                } else {
                    element.classList.remove('active');
                }
            });
            
            updateUI();
        }
        
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            
            const container = document.getElementById('notifications');
            container.appendChild(notification);
            
            // Remove notification after animation completes
            setTimeout(() => {
                if (notification.parentNode) {
                    container.removeChild(notification);
                }
            }, 4000); // 2s display + 2s fade out
        }
        
        function createWeaponModels() {
            // Create weapon models container
            player.weaponModels = {};
            
            // Pulse Rifle model
            const pulseRifleModel = new THREE.Group();
            const pulseRifleBarrel = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 3, 8),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            pulseRifleBarrel.rotation.x = Math.PI / 2;
            pulseRifleBarrel.position.z = -2;
            
            const pulseRifleBody = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.8, 2),
                new THREE.MeshStandardMaterial({ color: 0x444444 })
            );
            pulseRifleBody.position.z = -0.5;
            
            const pulseRifleGrip = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 1.5, 0.4),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            pulseRifleGrip.position.y = -1;
            pulseRifleGrip.position.z = 0;
            
            pulseRifleModel.add(pulseRifleBarrel);
            pulseRifleModel.add(pulseRifleBody);
            pulseRifleModel.add(pulseRifleGrip);
            pulseRifleModel.visible = false;
            scene.add(pulseRifleModel);
            player.weaponModels.pulseRifle = pulseRifleModel;
            
            // Cyber Shotgun model
            const cyberShotgunModel = new THREE.Group();
            const cyberShotgunBarrel = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.3, 2.5, 8),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            cyberShotgunBarrel.rotation.x = Math.PI / 2;
            cyberShotgunBarrel.position.z = -1.8;
            
            const cyberShotgunBody = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.9, 2.2),
                new THREE.MeshStandardMaterial({ color: 0x990000 })
            );
            cyberShotgunBody.position.z = -0.5;
            
            const cyberShotgunGrip = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 1.5, 0.5),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            cyberShotgunGrip.position.y = -1;
            cyberShotgunGrip.position.z = 0;
            
            cyberShotgunModel.add(cyberShotgunBarrel);
            cyberShotgunModel.add(cyberShotgunBody);
            cyberShotgunModel.add(cyberShotgunGrip);
            cyberShotgunModel.visible = false;
            scene.add(cyberShotgunModel);
            player.weaponModels.cyberShotgun = cyberShotgunModel;
            
            // Plasma Launcher model
            const plasmaLauncherModel = new THREE.Group();
            const plasmaLauncherBarrel = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.4, 2, 8),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            plasmaLauncherBarrel.rotation.x = Math.PI / 2;
            plasmaLauncherBarrel.position.z = -2;
            
            const plasmaLauncherBody = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 1, 2.5),
                new THREE.MeshStandardMaterial({ color: 0x006699 })
            );
            plasmaLauncherBody.position.z = -0.5;
            
            const plasmaLauncherGrip = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 1.5, 0.6),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            plasmaLauncherGrip.position.y = -1;
            plasmaLauncherGrip.position.z = 0;
            
            const plasmaLauncherTube = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8),
                new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.3 })
            );
            plasmaLauncherTube.position.y = 0.6;
            plasmaLauncherTube.position.z = -0.5;
            
            plasmaLauncherModel.add(plasmaLauncherBarrel);
            plasmaLauncherModel.add(plasmaLauncherBody);
            plasmaLauncherModel.add(plasmaLauncherGrip);
            plasmaLauncherModel.add(plasmaLauncherTube);
            plasmaLauncherModel.visible = false;
            scene.add(plasmaLauncherModel);
            player.weaponModels.plasmaLauncher = plasmaLauncherModel;
            
            // Electric Katana model
            const electricKatanaModel = new THREE.Group();
            const katanaHandle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.1, 1.2, 8),
                new THREE.MeshStandardMaterial({ color: 0x111111 })
            );
            
            const katanaBlade = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.6, 3),
                new THREE.MeshStandardMaterial({ 
                    color: 0xcccccc, 
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.3,
                    metalness: 0.9,
                    roughness: 0.1
                })
            );
            katanaBlade.position.z = -2;
            
            electricKatanaModel.add(katanaHandle);
            electricKatanaModel.add(katanaBlade);
            electricKatanaModel.visible = false;
            scene.add(electricKatanaModel);
            player.weaponModels.electricKatana = electricKatanaModel;
            
            // Make pulse rifle visible by default
            player.weaponModels.pulseRifle.visible = true;
            weaponModel = player.weaponModels.pulseRifle;
        }
        
        function showWeapon() {
            // Hide all weapons
            for (const model in player.weaponModels) {
                player.weaponModels[model].visible = false;
            }
            
            // Show selected weapon
            player.weaponModels[player.currentWeapon].visible = true;
            weaponModel = player.weaponModels[player.currentWeapon];
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (!isGameStarted || isPaused) {
                return;
            }
            
            // Calculate delta time
            const currentTime = performance.now();
            if (prevTime === 0) {
                // First frame, just initialize prevTime
                prevTime = currentTime;
                return; // Skip first frame to avoid huge delta
            }
            
            deltaTime = (currentTime - prevTime) / 1000; // Convert to seconds
            prevTime = currentTime;
            
            // Limit delta time to avoid large jumps
            if (deltaTime > 0.1) {
                deltaTime = 0.1;
            }
            
            // Update game state
            elapsedTime += deltaTime;
            
            // Handle player movement
            updatePlayerPosition();
            
            // Update weapon position - FIXED position relative to camera
            if (weaponModel) {
                // Create a fixed position in the bottom right of the screen
                // We use the camera's world matrix to position the weapon relative to the camera
                const cameraDirection = new THREE.Vector3(0, 0, -1);
                cameraDirection.applyQuaternion(camera.quaternion);
                
                const cameraRight = new THREE.Vector3(1, 0, 0);
                cameraRight.applyQuaternion(camera.quaternion);
                
                const cameraUp = new THREE.Vector3(0, 1, 0);
                cameraUp.applyQuaternion(camera.quaternion);
                
                // Position the weapon in a fixed location relative to camera view
                weaponModel.position.copy(camera.position);
                
                // Offset based on camera orientation vectors
                weaponModel.position.add(cameraDirection.multiplyScalar(-0.7)); // Forward
                weaponModel.position.add(cameraRight.multiplyScalar(0.4)); // Right
                weaponModel.position.add(cameraUp.multiplyScalar(-0.3)); // Down
                
                // Apply the camera's rotation to the weapon
                weaponModel.quaternion.copy(camera.quaternion);
                
                // Add a slight bobbing effect based on movement
                if (moveState.forward || moveState.backward || moveState.left || moveState.right) {
                    const bobAmount = 0.02;
                    const bobSpeed = 5;
                    weaponModel.position.y += Math.sin(elapsedTime * bobSpeed) * bobAmount;
                }
            }
            
            // Update entities
            updateEnemies();
            updateBullets();
            updatePickups();
            
            // Game progress checks
            checkWaveProgress();
            
            // Render
            renderer.render(scene, camera);
        }
        
        // Initialize the game when the page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html> 